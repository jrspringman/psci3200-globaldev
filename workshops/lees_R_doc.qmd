---
title: "Live R Coding Session"
author: "Jeremy Springman"

institute: "University of Pennsylvania"
date: last-modified
toc: true

bibliography: references.bib

format: 
  html:
    self-contained: true

editor: source
---

# RStudio Layout

Before using R to illustrate basic programming concepts and data analysis tools, we will get familiar with the RStudio layout.

## Rstudio contains 4 panes

RStudio has four primary panels that will help you interact with your data. We will use the default layout of these panels.

-   Source panel: Top left
    -   Edit files to create 'scripts' of code
-   Console panel: Bottom left
    -   Accepts code as input
    -   Displays output when we run code
-   Environment panel: Top right
    -   Everything that R is holding in memory
    -   Objects that you create in the console or source panels will appear here
    -   You can clear the environment with the broom icon
-   Viewer panel: Bottom-right
    -   View graphics that you generate
    -   Navigate files

## Illustration

Let's use these panels to create and interact with data.

**Console:**

-   Perform a calculation: type `2 + 2` into the console panel and hit ENTER
-   Create and store an object: type `sum = 2 + 2` into the console panel and hit ENTER

**Source:**

-   Start an R script: Open new .R file (button in top-left below "File")
-   Create and store an object: type `sum = 2 + 3` into the source panel and hit cntrl+ENTER

**Environment:**

-   Confirm that the object `sum` is stored in our environment
-   Use `rm(sum)` to clear the object from the environment
-   Clear the environment with the broom icon

**Viewer:**

-   Navigate through your computer's files
-   Create a plot in the source panel

```{r }
#| echo: true
#| include: false
#| warning: false
#| message: false

## Copy this into an .R file
data = data.frame(
  x1 = rnorm(100, mean = 1, sd = 1),
  x2 = rnorm(100, mean = 1, sd = 1)
)

plot(data$x1, data$x2)

```

# Review of Basic Programming Concepts

Now that we understand the layout, we are ready to review the concepts covered in `Module 2 Week 2.2`. These concepts will help us understand what is happening when we create and manipulate data.

## Objects: where values are saved in R

"Object" is a generic term for anything that R stores in the environment. This can include anything from an individual number or word, to lists of values, to entire datasets.

Importantly, objects belong to different "classes" depending on the type of values that they store.

-   Characters are text or strings like `"hello world"` and `"welcome to R"`.
-   Factors are a group of characters/strings with a fixed number of unique values
-   Logicals are either `TRUE` or `FALSE`

```{r }
#| echo: true
#| include: true
#| warning: true
#| message: true

# Create a numeric object
my_number = 5.6
# Check the class
class(my_number)

# Create a character object
my_character = "welcome to R"
# Check the class
class(my_character)

# Create a logical object
my_logical = FALSE
# Check the class
class(my_logical)

```

R can perform operations on objects.

```{r }
#| echo: true
#| include: true
#| warning: true
#| message: true

# Create a numeric object
my_number = 5.6
# Check the class
class(my_number)
# Perform a calculation
my_number + 5

```

The class of an object determines the type of operations you can perform on it. Some operations can only be run on numeric objects (numbers).

```{r , eval=FALSE}
#| echo: true
#| include: true
#| warning: true
#| message: true

# Create a character object
my_number = "5.6"
# Check the class
class(my_number)
# Perform a calculation
my_number + 5
round(my_number)

```

R contains functions that can convert some objects to different factors.

```{r }
#| echo: true
#| include: true
#| warning: false
#| message: false

# Convert character to numeric
my_number = as.numeric("5")
class(my_number)

# But R is only so smart
my_number = as.numeric("five")
class(my_number)

```

## Data Structures

The most simple objects are single values, but most data analysis involves more complicated data structures.

### Lists

Lists are a type of data structure that store multiple values together. Lists are created using `c()` and allow you to perform operations on a series of values.

```{r }
#| echo: true
#| include: true
#| warning: false
#| message: false

# Create a numeric list (also called a "vector")
numeric_vector = c(6, 11, 13, 31)
# Print the vector
print(numeric_vector)
# Check the class
class(numeric_vector)
# Calculate the mean
mean(numeric_vector)

```

An important part of working with more complex data structures is called "indexing." Indexing allows you to extract specific values from a data structure.

```{r }
#| echo: true
#| include: true
#| warning: false
#| message: false

# Extract the 2nd element from the list
numeric_vector[2]

# Extract elements 2-4
numeric_vector[2:4]

# Extract elements 1-2
numeric_vector[c(TRUE, TRUE, FALSE, FALSE)]


```

### Dataframes

Data frames are the most common type of data structure used in research. Data frames combine multiple lists of values into a single object.

```{r }
#| echo: true
#| include: true
#| warning: false
#| message: false

# Create a dataframe
my_data = data.frame(
  x1 = rnorm(100, mean = 1, sd = 1),
  x2 = rnorm(100, mean = 1, sd = 1)
)

class(my_data)

```

Anything that comes in a spreadsheet (for example, an excel file) can be loaded into an R environment as a dataframe. R works most easily when spreadsheets are saved as a `.csv` file.

```{r }
#| include: false
#| warning: false
#| message: false

# Use `read.csv()` to load data from a website
dat = read.csv("https://raw.githubusercontent.com/jrspringman/psci3200-globaldev/main/workshops/aau_survey/clean_endline_did.csv" ) 
# Use `read.csv()` to load data from your computer's Downloads folder
# dat = read.csv("/home/jeremy/Downloads/clean_endline_did.csv")

```

In most data frames, rows correspond to observations and the columns correspond to variables that describe the observations. Here, we are looking at survey data from an RCT involving university students in Addis Ababa. Each row correspondents to a different survey respondent, and each column represents their answers to a different question from the survey.

## Loading Packages

Packages are an extremely important part of data analysis with R. 

-   R gives you access to thousands of "packages" that are created by users
-   Packages contain bundles of code called "functions" that can execute specific tasks
-   Use `install.packages()` to install a package and `library()` to load a package

In the next section, we'll use the package `dplyr` to perform some data cleaning. `dplyr` is part of a universe of packages called `tidyverse`. Since this is one of the most important packages in the R ecosystem, let's install and load it.

```{r }
#| include: false
#| warning: false
#| message: false

#install.packages("tidyverse")
library(tidyverse)

#install.packages("tidyverse")
library(modelsummary)


```

# Cleaning Data

In the real-world, data never comes ready to be analyzed. Data cleaning is the process of manipulating data so that it can be analyzed. This is usually the most difficult and time-consuming part of any data analysis project. Let's walk through some examples.

## Creating Variables

Imagine we want to analyze the relationship between whether a respondent moved to to Addis Ababa to attend university and their level of political participation.  However, there are two problems:

- We don't have a specific variable that measures whether or not respondents moved
- We have many measures of participation 

How can we create a variable measuring whether the respondent moved to Addis Ababa? We  have a multiple-choice question asking students about what region they come from.  

```{r }
#| include: false
#| warning: false
#| message: false

# Let's start with the variable measure respondents' home region
table(dat$q8_baseline)

dat = dat %>%
  # give our variable a better name
  rename(home_region = q8_baseline) %>%
  # clean home region variable
  mutate(
    # Shorten a long name to an abbreviation
    home_region = ifelse(home_region == "Southern Nations, Nationalities, and Peoples Region", "SNNPR", home_region),
    # remove the word "Region" from every observation of this column
    home_region = str_remove(home_region, " Region")
    )

# Check if it worked
table(dat$home_region)

```

```{r}
#| echo: false
#| warning: false

# Create independent variable
dat = dat %>% mutate(moved = case_when(home_region == "Addis Ababa" ~ 0, TRUE ~ 1) )


```



```{r}
#| echo: false
#| warning: false

# Create independent variable
dat = dat %>% mutate(moved = case_when(home_region == "Addis Ababa" ~ 0, TRUE ~ 1) )


# Contacted gov't official
# Signed a petition

# q13_4_1
# q13_5_1

#dat$add_participation_end = dat$q13_4_1 + dat$q13_5_1


## Find participation measures that are based on a count
add_ecols = grep("q13_4_1$|q13_5_1$", names(dat), value = T)

dat %>% select(add_ecols) %>% head(5)


dat = dat %>%
  mutate(add_participation_end =  rowSums(across(add_ecols) ) )
  #mutate(add_participation_end =  rowSums(across(add_ecols), na.rm = T) )


```


## Cleaning strings



# Regression



```{r}
#| echo: false
#| warning: false

table(dat$class_year)

dat = dat %>% mutate(year = as.numeric(case_when(class_year == "Year I" ~ 0,
                                                 class_year == "Year II" ~ NA,
                                                 class_year == "Year III" ~ 1 )) )
table(dat$year)

# models <- list()
# models[['Bivariate']] = lm(z_participation_base ~ moved, dat)
# models[['Multivariate']] = lm(z_participation_base ~ moved + year, dat)
# models[['Interaction']] = lm(z_participation_base ~ moved + year + moved*year, dat)
# 
# modelsummary(
#   models,
#   estimate  = "{estimate}{stars} ({std.error})",
#              statistic = NULL,
#   gof_omit = 'IC|RMSE|Log|F|R2$|Std.')

```


```{r}
#| echo: false
#| warning: false
#| 
# Predict values based on the model
# predictions <- predict(lm(z_participation_base ~ moved * year, dat), newdata = dat)
# 
# # Create a dataframe with predictions
# prediction_df <- data.frame(year = dat$year, moved = dat$moved, prediction = predictions)
# 
# # Plot the interaction
# ggplot(prediction_df, aes(x = year, y = prediction, color = factor(moved))) +
#   geom_line() +
#   geom_point() +
#   scale_x_continuous(breaks = c(0, 1), labels=c("Y1", "Y3")) +
#   labs(x = "Year", y = "Predicted z_participation_base", color = "Moved") +
#   ggtitle("Interaction Plot of z_participation_base by Year and Moved")

```

### Continuous-ish

```{r}
#| echo: false
#| warning: false

# dat = dat %>% mutate(year = as.numeric(case_when(class_year == "Year I" ~ 0,
#                                                  class_year == "Year II" ~ 1,
#                                                  class_year == "Year III" ~ 2 )) )
# table(dat$year)
# 
# models <- list()
# models[['Bivariate']] = lm(z_participation_base ~ moved, dat)
# models[['Multivariate']] = lm(z_participation_base ~ moved + year, dat)
# models[['Interaction']] = lm(z_participation_base ~ moved + year + moved*year, dat)
# 
# modelsummary(
#   models,
#   estimate  = "{estimate}{stars} ({std.error})",
#              statistic = NULL,
#   gof_omit = 'IC|RMSE|Log|F|R2$|Std.')

```



```{r}
#| echo: false
#| warning: false
# Predict values based on the model
# predictions <- predict(lm(z_participation_base ~ moved * year, dat), newdata = dat)
# 
# # Create a dataframe with predictions
# prediction_df <- data.frame(year = dat$year, moved = dat$moved, prediction = predictions)
# 
# # Plot the interaction
# ggplot(prediction_df, aes(x = year, y = prediction, color = factor(moved))) +
#   geom_line() +
#   geom_point() +
#   scale_x_continuous(breaks = c(0, 1, 2), labels=c("Y1", "Y2", "Y3")) +
#   labs(x = "Year", y = "Predicted z_participation_base", color = "Moved") +
#   ggtitle("Interaction Plot of z_participation_base by Year and Moved")

```





### Cross-Sectional

```{r}
#| echo: false
#| warning: false

# regd = dat %>% select(z_participation_end, z_participation_base, moved, response_id ) %>%
#   pivot_longer(cols = c(z_participation_end, z_participation_base),
#                names_to = "time",
#                values_to = "z_participation") %>%
#   mutate(time = case_when(time == "z_participation_end" ~ 1, 
#                           TRUE ~ 0))
# 
# models <- list()
# models[['Bivariate']] = lm(z_participation ~ moved, regd)
# models[['Multivariate']] = lm(z_participation ~ moved + time, regd)
# models[['Interaction']] = lm(z_participation ~ moved + time + moved*time, regd)
# 
# modelsummary(
#   models,
#   estimate  = "{estimate}{stars} ({std.error})",
#              statistic = NULL,
#   gof_omit = 'IC|RMSE|Log|F|R2$|Std.')

```




# Appendix




```{r}
#| echo: false
#| warning: false

# participation
participate = dat %>% 
  select(`Additive Index` = add_participation_end, 
         `Signed petition` = q13_5_1, 
         `Contact official` = q13_4_1) %>% 
  drop_na() %>% 
  pivot_longer(everything()) %>% 
  group_by(name, value) %>% 
  tally() %>% 
  mutate(pct = n/sum(n))



ggplot(participate, aes(x = value, y = pct)) + 
  # geom_col(fill = palette[9]) + 
  facet_wrap(vars(name), scales = "free") + 
  scale_y_continuous(labels = scales::percent) +
  labs(y = "Percent of respondents", x = NULL, 
       title = "How do youth participate?", 
       subtitle = glue::glue("Number of respondents = {scales::comma(sum(participate$n)/7)}")) 

```

## Averaged Z-Scores

```{r}
#| echo: false
#| warning: false


## Find participation measures that are based on likert
# baseline
bcols = grep("^q13_.*_baseline$", names(dat), value = T)
dat[, paste0(bcols, "_st")] = dat[, bcols]
bcols = paste0(bcols,"_st")

# endline
ecols = grep("^q13_[1-7]_\\d$", names(dat), value = T)
dat[, paste0(ecols, "_st")] = dat[, ecols]
ecols = paste0(ecols,"_st")


# Create treatment variable
dat = dat %>% mutate(moved = case_when(home_region == "Addis Ababa" ~ 0, TRUE ~ 1) )

# clean q13_
levels = c("Never", "Once or Twice", "More than twice", "More than 5 times", 
           "More than 10 times")
dat = dat %>% 
  mutate(across(c(bcols), 
                .fns = ~ factor(.x, levels = levels)))

# Create z-score function from Kling, Liberman, and Katz (2007)
z_score = function(x, y){
  # calculate mean and sd of control group
  c_mean = mean( as.numeric( unlist(x[, y])) , na.rm = T)
  c_sd = sd( as.numeric( unlist(x[, y])) , na.rm = T)
  # subtract control group mean; divide by control group SD
  ( as.numeric(x[, y, drop = TRUE]) - c_mean) / c_sd
}

# calculate z-scores
for (i in c(bcols, ecols)) {
  dat[,i] = z_score(dat, i)
}

dat = dat %>% 
  rowwise() %>% 
  mutate( z_participation_end = mean(c_across(all_of(bcols)), na.rm = TRUE)) %>% 
  mutate( z_participation_base = mean(c_across(all_of(ecols)), na.rm = TRUE)) %>%
  ungroup()

```



```{r}
#| echo: false
#| warning: false

# 
# # raw
# participate = dat %>% 
#   select(`Attend meeting` = q13_1_baseline, 
#          `Protest` = q13_2_baseline, 
#          `NGO event` = q13_3_baseline, 
#          `Signed petition` = q13_4_baseline, 
#          `Contact official` = q13_5_baseline, 
#          `Contact student representative` = q13_6_baseline, 
#          `Contact an NGO` = q13_7_baseline) %>% 
#   drop_na() %>% 
#   pivot_longer(everything()) %>% 
#   group_by(name, value) %>% 
#   tally() %>% 
#   mutate(pct = n/sum(n)) %>% 
#   mutate(value = fct_relevel(value, "Never", after = Inf), 
#          value = fct_rev(value))
# 
# ggplot(participate , aes(x = value, y = pct)) + 
#   # geom_col(fill = palette[9]) + 
#   facet_wrap(vars(name), scales = "free", ncol = 2) + 
#   scale_y_continuous(labels = scales::percent) +
#   labs(y = "Percent of respondents", x = NULL, 
#        title = "How do youth participate?", 
#        subtitle = glue::glue("Number of respondents = {scales::comma(sum(participate$n)/7)}")) + 
#   scale_x_discrete(labels = scales::label_wrap(10))

```

```{r}
#| echo: false
#| warning: false

# # standardized
# participate = dat %>% 
#   select(`Z-Score Index` = z_participation_base,
#          `Attend meeting` = q13_1_baseline_st, 
#          `Protest` = q13_2_baseline_st, 
#          `NGO event` = q13_3_baseline_st, 
#          `Signed petition` = q13_4_baseline_st, 
#          `Contact official` = q13_5_baseline_st, 
#          `Contact student representative` = q13_6_baseline_st, 
#          `Contact an NGO` = q13_7_baseline_st) %>% 
#   drop_na() %>% 
#   pivot_longer(everything()) 
# 
# 
# ggplot(participate , aes(x = value )) + 
#   geom_histogram(aes(y = after_stat(count / sum(count))), 
#                  binwidth=.5, fill = palette[9]) +
#   #geom_col(fill = palette[9]) + 
#   facet_wrap(vars(name),  ncol = 2) + 
#   scale_y_continuous(labels = scales::percent) +
#   labs(y = "Percent of respondents", x = NULL, 
#        title = "How do youth participate?")


```



## More complex

```{r}
#| echo: false
#| warning: false

dat = dat %>% mutate(year1 = as.numeric(case_when(class_year == "Year I" ~ 1,
                                                 class_year == "Year II" ~ 0,
                                                 class_year == "Year III" ~ 0 )),
                     year2 = as.numeric(case_when(class_year == "Year I" ~ 0,
                                                 class_year == "Year II" ~ 1,
                                                 class_year == "Year III" ~ 0 )),
                     year3 = as.numeric(case_when(class_year == "Year I" ~ 0,
                                                 class_year == "Year II" ~ 0,
                                                 class_year == "Year III" ~ 1 )),)
table(dat$year)

models <- list()
models[['Bivariate']] = lm(z_participation_base ~ moved, dat)
models[['Multivariate']] = lm(z_participation_base ~ moved + year2 + year3, dat)
models[['Interaction']] = lm(z_participation_base ~ moved + year2 + year2*moved + year3 + year3*moved , dat)

modelsummary(
  models,
  estimate  = "{estimate}{stars} ({std.error})",
             statistic = NULL,
  gof_omit = 'IC|RMSE|Log|F|R2$|Std.')

```

```{r}
#| echo: false
#| warning: false

# Assuming dat already has year2 and year3 as binary indicators
# If not, create them based on your criteria for what constitutes year2 and year3

# Model including interactions
model <- lm(z_participation_base ~ moved + year2 + year2*moved + year3 + year3*moved, dat)

# Generate new data for predictions
# This data should cover all combinations of moved, year2, and year3
newdata <- expand.grid(moved = c(0, 1), year2 = c(0, 1), year3 = c(0, 1))

# Exclude impossible combinations (e.g., year2 and year3 both being 1)
newdata <- newdata[!with(newdata, year2 == 1 & year3 == 1),]

# Predict values
predictions <- predict(model, newdata = newdata)

# Add predictions to the newdata dataframe
newdata$prediction <- predictions

# Convert year2 and year3 back to a single year variable for plotting
newdata$year <- with(newdata, ifelse(year2 == 1, "1", ifelse(year3 == 1, "2", "0")))

# Plot
library(ggplot2)
ggplot(newdata, aes(x = as.numeric(year), y = prediction, color = factor(moved))) +
  geom_point() +
  geom_line() +
  scale_x_continuous(breaks = c(0, 1, 2), labels=c("Y1", "Y2", "Y3")) +
  labs(x = "Year", y = "Predicted z_participation_base", color = "Moved") +
  ggtitle("Interaction Plot of z_participation_base by Year and Moved")


```

## Differences over time



```{r}
#| echo: false
#| warning: false
# Predict values based on the model
# predictions <- predict(lm(z_participation ~ moved*time, regd), newdata = regd)
# 
# # Create a dataframe with predictions
# prediction_df <- data.frame(time = regd$time, moved = regd$moved, prediction = predictions)
# 
# # Plot the interaction
# ggplot(prediction_df, aes(x = time, y = prediction, color = factor(moved))) +
#   geom_line() +
#   geom_point() +
#   scale_x_continuous(breaks = c(0, 1)) +
#   labs(x = "Year", y = "Predicted z_participation", color = "Moved") +
#   ggtitle("Interaction Plot of z_participation_base by Year and Moved")

```




